<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××—×©×‘×•×Ÿ ×œ××™××•× ×™×</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            color: #333;
        }

        body[dir="rtl"] {
            text-align: right;
        }

        body[dir="ltr"] {
            text-align: left;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .lang-switcher {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        body[dir="rtl"] .lang-switcher {
            right: auto;
            left: 15px;
        }

        .lang-switcher:hover {
            background: rgba(255,255,255,0.3);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .section {
            padding: 20px;
            display: none;
        }

        .section.active {
            display: block;
        }

        .instruction-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
        }

        .selected-role-display {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 600;
            color: #155724;
            display: none;
        }

        .selected-role-display.show {
            display: block;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 24px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: 600;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .btn:active {
            transform: scale(0.97);
            opacity: 0.9;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .role-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .role-btn {
            padding: 15px 8px;
            background: #f8f9fa;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 14px;
            touch-action: manipulation;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .role-btn:active {
            transform: scale(0.95);
        }

        .role-btn.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transform: scale(1.05);
        }

        .drill-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 5px solid #667eea;
        }

        body[dir="rtl"] .drill-card {
            border-left: none;
            border-right: 5px solid #667eea;
        }

        .drill-card.white {
            border-color: #28a745;
            background: #f1f9f3;
        }

        .drill-card.mixed {
            border-color: #ffc107;
            background: #fffbf0;
        }

        .drill-card.gray {
            border-color: #6c757d;
            background: #f5f5f5;
        }

        .drill-card.category-attack {
            border-top: 4px solid #dc3545;
        }

        .drill-card.category-defense {
            border-top: 4px solid #28a745;
        }

        .drill-card.category-physical {
            border-top: 4px solid #6f42c1;
        }

        .drill-card.category-possession {
            border-top: 4px solid #fd7e14;
        }

        .drill-card h3 {
            font-size: 18px;
            margin-bottom: 8px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .drill-stats {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .drill-attrs {
            font-size: 13px;
            color: #555;
            line-height: 1.6;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 5px;
        }

        body[dir="rtl"] .badge {
            margin-right: 0;
            margin-left: 5px;
        }

        .badge-difficulty {
            background: #667eea;
            color: white;
        }

        .badge-category {
            font-size: 11px;
            padding: 3px 7px;
        }

        .badge-attack {
            background: #dc3545;
            color: white;
        }

        .badge-defense {
            background: #28a745;
            color: white;
        }

        .badge-physical {
            background: #6f42c1;
            color: white;
        }

        .badge-possession {
            background: #fd7e14;
            color: white;
        }

        .priority-header {
            background: #667eea;
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .priority-header.white {
            background: #28a745;
        }

        .priority-header.mixed {
            background: #ffc107;
            color: #333;
        }

        .priority-header.gray {
            background: #6c757d;
        }

        .attr-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
            direction: ltr; /* Keep columns left-to-right regardless of page direction */
        }

        .summary-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .summary-box h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .category-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .attributes-display {
            margin-bottom: 20px;
        }

        .attributes-display h4 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .attr-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .attr-item.white {
            background: #f1f9f3;
            border-left: 3px solid #28a745;
        }

        body[dir="rtl"] .attr-item.white {
            border-left: none;
            border-right: 3px solid #28a745;
        }

        .attr-item.gray {
            background: #f5f5f5;
            border-left: 3px solid #6c757d;
        }

        body[dir="rtl"] .attr-item.gray {
            border-left: none;
            border-right: 3px solid #6c757d;
        }

        .no-drills {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .filter-panel {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 20px;
        }

        .filter-panel-title {
            font-weight: 600;
            font-size: 15px;
            color: #333;
            margin-bottom: 10px;
        }

        .filter-attr-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 6px;
        }

        .filter-attr-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            padding: 5px 8px;
            border-radius: 6px;
            background: white;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            user-select: none;
        }

        .filter-attr-item:hover {
            border-color: #667eea;
        }

        .filter-attr-item input[type="checkbox"] {
            width: 15px;
            height: 15px;
            cursor: pointer;
            accent-color: #667eea;
            flex-shrink: 0;
        }

        .filter-attr-item.is-white {
            border-color: #c3e6cb;
            background: #f1f9f3;
        }

        @media (max-width: 600px) {
            .attr-grid {
                grid-template-columns: 1fr;
            }

            .role-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body dir="rtl">
    <div class="container">
        <div class="header">
            <button class="lang-switcher" onclick="toggleLanguage()">English</button>
            <h1 id="headerTitle">âš½ ××—×©×‘×•×Ÿ ×œ××™××•× ×™×</h1>
            <p id="headerSubtitle">××¦× ××ª ×”×ª×¨×’×™×œ×™× ×”×˜×•×‘×™× ×‘×™×•×ª×¨ ×œ×©×—×§×Ÿ ×©×œ×š</p>
        </div>

        <!-- Role Selection Section -->
        <div id="roleSection" class="section active">
            <h2 style="margin-bottom: 15px;" id="roleTitle">×‘×—×¨ ×ª×¤×§×™×“ ×©×—×§×Ÿ</h2>
            <div class="instruction-box">
                <span id="roleInstruction">ğŸ‘† <strong>×©×œ×‘ 1:</strong> ×œ×—×¥ ×¢×œ ×ª×¤×§×™×“ ×›×“×™ ×œ×‘×—×•×¨ ××•×ª×•</span>
            </div>
            <div class="selected-role-display" id="selectedRoleBox">
                <span id="selectedPrefix">âœ“ × ×‘×—×¨:</span> <span id="selectedRoleText"></span>
            </div>
            <div id="roleGrid" class="role-grid"></div>
            <button class="btn" onclick="continueToAttributes()"><span id="continueBtn">×”××©×š â†</span></button>
        </div>

        <!-- Attributes Input Section -->
        <div id="attributesSection" class="section">
            <h2 style="margin-bottom: 15px;" id="attrTitle">×”×–×Ÿ ×××¤×™×™× ×™ ×©×—×§×Ÿ</h2>
            <p style="margin-bottom: 20px; color: #666;"><span id="roleLabel">×ª×¤×§×™×“:</span> <strong id="selectedRoleName"></strong></p>
            <div class="instruction-box">
                <span id="attrInstruction">â­ = ×××¤×™×™× ×™× ×—×©×•×‘×™× (×œ×‘×Ÿ) ×œ×ª×¤×§×™×“ ×–×”</span>
            </div>
            <div id="attributesForm"></div>
            <button class="btn" onclick="calculateRecommendations()"><span id="getRecsBtn">×§×‘×œ ×”××œ×¦×•×ª âš¡</span></button>
            <button class="btn btn-secondary" onclick="backToRoles()"><span id="backBtn1">â†’ ×—×–×•×¨</span></button>
        </div>

        <!-- Recommendations Section -->
        <div id="recommendationsSection" class="section">
            <h2 style="margin-bottom: 15px;" id="recsTitle">×”××œ×¦×•×ª ××™××•×Ÿ</h2>
            <p style="margin-bottom: 20px; color: #666;"><span id="roleLabel2">×ª×¤×§×™×“:</span> <strong id="recRoleName"></strong></p>

            <div class="summary-box" id="summaryBox"></div>

            <button class="btn" onclick="generateFullPlan()" style="margin-bottom: 20px; background: linear-gradient(135deg, #ff9800 0%, #ff5722 100%);">
                <span id="fullPlanBtn">ğŸ“‹ ×ª×•×›× ×™×ª ××™××•× ×™× ××œ××” (BETA - ××œ ×ª×¡×ª××š!)</span>
            </button>

            <div class="filter-panel" id="attrFilterPanel">
                <div class="filter-panel-title" id="filterPanelTitle">ğŸ” ×¡× ×Ÿ ×œ×¤×™ ×××¤×™×™× ×™×</div>
                <div class="filter-attr-grid" id="filterAttrGrid"></div>
            </div>

            <div id="recommendationsList"></div>

            <div class="action-buttons">
                <button class="btn btn-success" onclick="updateAttributes()"><span id="updateBtn">×¢×“×›×Ÿ ×××¤×™×™× ×™×</span></button>
                <button class="btn btn-secondary" onclick="viewAttributes()"><span id="viewBtn">×¦×¤×” ×‘×××¤×™×™× ×™×</span></button>
            </div>
            <button class="btn" onclick="backToRoles()" style="margin-top: 10px;"><span id="startOverBtn">â†’ ×”×ª×—×œ ××—×“×©</span></button>
        </div>

        <!-- Full Training Plan Section -->
        <div id="fullPlanSection" class="section">
            <h2 style="margin-bottom: 15px;" id="fullPlanTitle">×ª×•×›× ×™×ª ××™××•× ×™× ××œ××”</h2>
            <p style="margin-bottom: 20px; color: #666;"><span id="roleLabel4">×ª×¤×§×™×“:</span> <strong id="planRoleName"></strong></p>

            <div id="planSummary" class="summary-box"></div>
            <div id="planSteps"></div>

            <button class="btn" onclick="backToRecommendations()" style="margin-top: 20px;"><span id="backToPlanRecsBtn">â†’ ×—×–×•×¨ ×œ×”××œ×¦×•×ª</span></button>
        </div>

        <!-- View Attributes Section -->
        <div id="viewAttributesSection" class="section">
            <h2 style="margin-bottom: 15px;" id="viewAttrTitle">×××¤×™×™× ×™× × ×•×›×—×™×™×</h2>
            <p style="margin-bottom: 20px; color: #666;"><span id="roleLabel3">×ª×¤×§×™×“:</span> <strong id="viewRoleName"></strong></p>
            <div id="attributesDisplay"></div>
            <button class="btn" onclick="backToRecommendations()"><span id="backToRecsBtn">â†’ ×—×–×•×¨ ×œ×”××œ×¦×•×ª</span></button>
        </div>

        <!-- Update Attributes Section -->
        <div id="updateSection" class="section">
            <h2 style="margin-bottom: 15px;" id="updateAttrTitle">×¢×“×›×Ÿ ×××¤×™×™× ×™ ×©×—×§×Ÿ</h2>
            <div class="instruction-box">
                <span id="updateInstruction">×”×–×Ÿ ×¢×¨×›×™× ×—×“×©×™× ×œ××—×¨ ××™××•×Ÿ. ×”×©××¨ ×¨×™×§ ×›×“×™ ×œ×©××•×¨ ×¢×œ ×”×¢×¨×š ×”× ×•×›×—×™.</span>
            </div>
            <div id="updateForm"></div>
            <button class="btn btn-success" onclick="saveUpdates()"><span id="saveBtn">×©××•×¨ ×•×—×©×‘ ××—×“×© âš¡</span></button>
            <button class="btn btn-secondary" onclick="backToRecommendations()"><span id="cancelBtn">â†’ ×‘×˜×œ</span></button>
        </div>
    </div>

    <script>
        // Language state
        let currentLang = 'he';

        // Translations
        const translations = {
            he: {
                // Header
                headerTitle: 'âš½ ××—×©×‘×•×Ÿ ×œ××™××•× ×™×',
                headerSubtitle: '××¦× ××ª ×”×ª×¨×’×™×œ×™× ×”×˜×•×‘×™× ×‘×™×•×ª×¨ ×œ×©×—×§×Ÿ ×©×œ×š',

                // Role Selection
                roleTitle: '×‘×—×¨ ×ª×¤×§×™×“ ×©×—×§×Ÿ',
                roleInstruction: 'ğŸ‘† <strong>×©×œ×‘ 1:</strong> ×œ×—×¥ ×¢×œ ×ª×¤×§×™×“ ×›×“×™ ×œ×‘×—×•×¨ ××•×ª×•',
                selectedPrefix: 'âœ“ × ×‘×—×¨:',
                continueBtn: '×”××©×š â†',

                // Attributes Input
                attrTitle: '×”×–×Ÿ ×××¤×™×™× ×™ ×©×—×§×Ÿ',
                roleLabel: '×ª×¤×§×™×“:',
                attrInstruction: 'â­ = ×××¤×™×™× ×™× ×—×©×•×‘×™× (×œ×‘×Ÿ) ×œ×ª×¤×§×™×“ ×–×”',
                getRecsBtn: '×§×‘×œ ×”××œ×¦×•×ª âš¡',
                backBtn: 'â†’ ×—×–×•×¨',
                playerTierLabel: 'â­ ×“×¨×’×ª ×©×—×§×Ÿ',
                tierNote: 'ğŸ’¡ <strong>×”×¢×¨×”:</strong> ×”×–×Ÿ ××ª ×”×¢×¨×›×™× ×”×›×•×œ×œ×™× ×©××ª×” ×¨×•××” ×‘××©×—×§ (×”×›×•×œ×œ ××ª ×‘×•× ×•×¡ ×”×“×¨×’×”). ×‘×•× ×•×¡ ×”×“×¨×’×” ×™×•×¤×—×ª ××××¤×™×™× ×™× ×œ×‘× ×™× ×‘×¢×ª ×—×™×©×•×‘ ×™×¢×™×œ×•×ª ×ª×¨×’×™×œ (×¡×£ 179.5).',

                // Recommendations
                recsTitle: '×”××œ×¦×•×ª ××™××•×Ÿ',
                filterPanelTitle: 'ğŸ” ×¡× ×Ÿ ×œ×¤×™ ×××¤×™×™× ×™×',
                updateBtn: '×¢×“×›×Ÿ ×××¤×™×™× ×™×',
                viewBtn: '×¦×¤×” ×‘×××¤×™×™× ×™×',
                fullPlanBtn: 'ğŸ“‹ ×ª×•×›× ×™×ª ××™××•× ×™× ××œ××” (BETA)',
                betaWarning: '×’×¨×¡×ª × ×™×¡×™×•×Ÿ (BETA)',
                betaWarningText: '×ª×•×›× ×™×ª ×”××™××•× ×™× ×”×™× ×‘×’×¨×¡×ª × ×™×¡×™×•×Ÿ. ××™×Ÿ ×œ×”×¡×ª××š ×¢×œ×™×” ×‘××•×¤×Ÿ ××•×—×œ×˜. ×”×©×ª××© ×‘×©×™×§×•×œ ×“×¢×ª×š.',
                startOverBtn: 'â†’ ×”×ª×—×œ ××—×“×©',
                summary: '×¡×™×›×•×',
                playerTier: '×“×¨×’×ª ×©×—×§×Ÿ:',
                tierIncluded: '× ×›×œ×œ ×‘×××¤×™×™× ×™× ×œ×‘× ×™×',
                tierSubtracted: '×‘×•× ×•×¡ ×”×“×¨×’×” ××•×¤×—×ª ××”×—×™×©×•×‘ (×¢×¨×›×™ ×‘×¡×™×¡ ××©××©×™× ×œ×¡×£ 179.5)',
                effectiveDrills: '×ª×¨×’×™×œ×™× ×™×¢×™×œ×™×:',
                whiteOnly: '×œ×‘×Ÿ ×‘×œ×‘×“:',
                mixed: '××¢×•×¨×‘:',
                grayOnly: '××¤×•×¨ ×‘×œ×‘×“:',
                ineffective: '×œ× ×™×¢×™×œ:',
                priority1: 'â­ ×¢×“×™×¤×•×ª 1: ×××¤×™×™× ×™× ×œ×‘× ×™× ×‘×œ×‘×“',
                priority2: 'âš¡ ×¢×“×™×¤×•×ª 2: ××¢×•×¨×‘ (×œ×‘×Ÿ + ××¤×•×¨)',
                priority3: 'â—¾ ×¢×“×™×¤×•×ª 3: ×××¤×™×™× ×™× ××¤×•×¨×™× ×‘×œ×‘×“',
                noDrills: '×œ× × ××¦××• ×ª×¨×’×™×œ×™×',

                // View Attributes
                viewAttrTitle: '×××¤×™×™× ×™× × ×•×›×—×™×™×',
                backToRecsBtn: 'â†’ ×—×–×•×¨ ×œ×”××œ×¦×•×ª',
                whitePrimary: 'â­ ×××¤×™×™× ×™× ×œ×‘× ×™× (×¢×™×§×¨×™×™×)',
                graySecondary: 'â—¾ ×××¤×™×™× ×™× ××¤×•×¨×™× (××©× ×™×™×)',
                bonusIncluded: '×‘×•× ×•×¡ × ×›×œ×œ ×‘×××¤×™×™× ×™× ×œ×‘× ×™×',
                base: '×‘×¡×™×¡',

                // Update Attributes
                updateAttrTitle: '×¢×“×›×Ÿ ×××¤×™×™× ×™ ×©×—×§×Ÿ',
                updateInstruction: '×”×–×Ÿ ×¢×¨×›×™× ×—×“×©×™× ×œ××—×¨ ××™××•×Ÿ. ×”×©××¨ ×¨×™×§ ×›×“×™ ×œ×©××•×¨ ×¢×œ ×”×¢×¨×š ×”× ×•×›×—×™.',
                saveBtn: '×©××•×¨ ×•×—×©×‘ ××—×“×© âš¡',
                cancelBtn: 'â†’ ×‘×˜×œ',

                // Full Training Plan
                fullPlanTitle: '×ª×•×›× ×™×ª ××™××•× ×™× ××œ××”',
                planSummary: '×¡×™×›×•× ×ª×•×›× ×™×ª',
                currentRating: '×“×™×¨×•×’ × ×•×›×—×™:',
                targetRating: '×“×™×¨×•×’ ×™×¢×“:',
                totalDrills: '×¡×š ×ª×¨×’×™×œ×™×:',
                newRating: '×“×™×¨×•×’ ×—×“×©:',
                finalAttributes: '×××¤×™×™× ×™× ×¡×•×¤×™×™×',
                step: '×©×œ×‘',
                trains: 'â†’',
                backToPlanRecsBtn: 'â†’ ×—×–×•×¨ ×œ×”××œ×¦×•×ª',
                roleLabel4: '×ª×¤×§×™×“:',

                // Overall Rating
                overallRating: '××™×›×•×ª ×›×œ×œ×™×ª',
                overallBase: '×‘×¡×™×¡ (×œ×œ× ×‘×•× ×•×¡):',
                overallWithBonus: '×¢× ×‘×•× ×•×¡ ×“×¨×’×”:',

                // Drill stats
                whiteAvg: '×××•×¦×¢ ×œ×‘×Ÿ:',
                grayAvg: '×××•×¦×¢ ××¤×•×¨:',
                overall: '×›×œ×œ×™:',
                potential: '×¤×•×˜× ×¦×™××œ:',
                whitePotential: '×¤×•×˜× ×¦×™××œ ×œ×‘×Ÿ:',
                grayPotential: '×¤×•×˜× ×¦×™××œ ××¤×•×¨:',
                white: '×œ×‘×Ÿ:',
                gray: '××¤×•×¨:',
                trains: 'â†’',

                // Category names
                attack: '×”×ª×§×¤×”',
                defense: '×”×’× ×”',
                physical: '×¤×™×–×™ ×•×× ×˜×œ×™',
                possession: '×”×—×–×§×ª ×›×“×•×¨',

                // Difficulty levels
                difficulties: {
                    'VERY EASY': '×§×œ ×××•×“',
                    'EASY': '×§×œ',
                    'MEDIUM': '×‘×™× ×•× ×™',
                    'HARD': '×§×©×”',
                    'VERY HARD': '×§×©×” ×××•×“'
                },

                // Attributes
                attrs: {
                    'Tackling': '×ª×™×§×•×œ',
                    'Marking': '×¡×™××•×Ÿ',
                    'Positioning': '××™×§×•×',
                    'Heading': '× ×’×™×—×”',
                    'Bravery': '××•××¥',
                    'Passing': '××¡×™×¨×•×ª',
                    'Dribbling': '×›×“×¨×•×¨',
                    'Crossing': '×”×¨××•×ª',
                    'Shooting': '×‘×¢×™×˜×•×ª',
                    'Finishing': '×¡×™×•××ª',
                    'Fitness': '×›×•×©×¨',
                    'Strength': '×›×•×—',
                    'Aggression': '××’×¨×¡×™×‘×™×•×ª',
                    'Speed': '××”×™×¨×•×ª',
                    'Creativity': '×™×¦×™×¨×ª×™×•×ª',
                    'Reflexes': '×¨×¤×œ×§×¡×™×',
                    'Agility': '×–×¨×™×–×•×ª',
                    'Anticipation': '×™×›×•×œ×ª ×—×™×–×•×™',
                    'Rushing out': '×™×¦×™××”',
                    'Communication': '×ª×§×©×•×¨×ª',
                    'Throwing': '×–×¨×™×§×”',
                    'Kicking': '×‘×¢×™×˜×•×ª',
                    'Punching': '×—×‘×˜×”',
                    'Aerial reach': '×™×›×•×œ×ª ××•×•×™×¨×™×ª',
                    'Concentration': '×¨×™×›×•×–'
                },

                // Tiers
                tiers: {
                    'None': '×¨×™×§',
                    'Rare': '× ×“×™×¨',
                    'Elite': '×¦××¨×ª',
                    'Stellar': '××¦×˜×™×™×Ÿ',
                    'Master': '×××¡×˜×¨',
                    'Epic': '××“×™×¨',
                    'Legendary': '××’×“×™'
                },

                // Drills
                drills: {
                    '1-on-1 Finishing': '×¡×™×•××ª 1-×¢×œ-1',
                    'Pass, Go and Shoot!': '××¡×•×¨, ×”×ª×§×“× ×•×‘×¢×˜!',
                    'Set-Piece Delivery': '×‘×™×¦×•×¢ ××¦×‘ × ×™×™×—',
                    'Shooting Technique': '×˜×›× ×™×§×ª ×‘×¢×™×˜×” ×œ×©×¢×¨',
                    'Slalom Dribble': '×“×¨×™×‘×œ ×‘×¡×œ××œ×•×',
                    'Wing Play': '××©×—×§ ××’×¤×™×',
                    'Fast Counter-Attacks': '×”×ª×§×¤×•×ª-× ×’×“ ××”×™×¨×•×ª',
                    'Video Analysis': '× ×™×ª×•×— ×¡×¨×˜×•× ×™ ×•×™×“××•',
                    'Use Your Head': '×”×©×ª××© ×‘×¨××© ×©×œ×š',
                    'One Line of Defense': '×§×• ×”×’× ×” ××—×“',
                    'Stop the Attacker': '×¢×¦×•×¨ ××ª ×©×—×§×Ÿ ×”×”×ª×§×¤×”',
                    'Defending Crosses': '×”×’×‘×”×” ×œ×”×’× ×”',
                    'Press the Play': '×“×—×•×§ ××ª ×©×—×§× ×™ ×”×”×ª×§×¤×”',
                    'Goalkeeper Training': '××™××•×Ÿ ×©×•×¢×¨×™×',
                    'Warm-Up': '×—×™××•×',
                    'Stretch': '××ª×™×—×•×ª',
                    'Carioca with Ladders': '×¦×¢×“ ×ª×™×× ×™ ×¢× ×¡×•×œ×',
                    'Long Run': '×¨×™×¦×” ××¨×•×›×”',
                    'Shuttle Runs': '×¨×™×¦×ª ×”×œ×•×š ×•×©×•×‘',
                    'Hurdle Jumps': '×§×¤×™×¦×ª ××©×•×›×•×ª',
                    'Gym': '×—×“×¨ ×›×•×©×¨',
                    'Sprint': '×¡×¤×¨×™× ×˜',
                    'Ball Control': '×©×œ×™×˜×” ×‘×›×“×•×¨',
                    'Piggy in the Middle': '××—×“ ×‘×××¦×¢',
                    'First Touch Play': '××©×—×§ ×‘× ×’×™×¢×” ×¨××©×•× ×”',
                    'Rapid Side Switch': '×”×—×œ×¤×ª ×¦×“×“×™× ××”×™×¨×”',
                    'Stay in Lane': '×©××™×¨×” ×¢×œ ××¡×œ×•×œ',
                    'Contact Play': '××©×—×§ ××’×¢',
                    'Passes Before Shot': '××¡×™×¨×•×ª ×œ×¤× ×™ ×‘×¢×™×˜×” ×œ×©×¢×¨'
                }
            },
            en: {
                // Header
                headerTitle: 'âš½ Football Training Optimizer',
                headerSubtitle: 'Find the best drills for your player',

                // Role Selection
                roleTitle: 'Select Player Role',
                roleInstruction: 'ğŸ‘† <strong>Step 1:</strong> Tap a role below to select it',
                selectedPrefix: 'âœ“ Selected:',
                continueBtn: 'Continue â†’',

                // Attributes Input
                attrTitle: 'Enter Player Attributes',
                roleLabel: 'Role:',
                attrInstruction: 'â­ = Important (WHITE) attributes for this role',
                getRecsBtn: 'Get Recommendations âš¡',
                backBtn: 'â† Back',
                playerTierLabel: 'â­ Player Tier',
                tierNote: 'ğŸ’¡ <strong>Note:</strong> Enter the TOTAL values you see in the game (which includes the tier bonus). The tier bonus will be subtracted from WHITE attributes when calculating drill effectiveness (179.5 threshold).',

                // Recommendations
                recsTitle: 'Training Recommendations',
                filterPanelTitle: 'ğŸ” Filter by Attributes',
                updateBtn: 'Update Attributes',
                viewBtn: 'View Attributes',
                fullPlanBtn: 'ğŸ“‹ Full Training Plan (BETA)',
                betaWarning: 'Beta Version (BETA)',
                betaWarningText: 'The training plan is in beta version. Do not rely on it completely. Use your own judgment.',
                startOverBtn: 'â† Start Over',
                summary: 'Summary',
                playerTier: 'Player Tier:',
                tierIncluded: 'included in WHITE attributes',
                tierSubtracted: 'Tier bonus subtracted from calculation (base values used for 179.5 threshold)',
                effectiveDrills: 'Effective Drills:',
                whiteOnly: 'White-only:',
                mixed: 'Mixed:',
                grayOnly: 'Gray-only:',
                ineffective: 'Ineffective:',
                priority1: 'â­ Priority 1: WHITE Attributes Only',
                priority2: 'âš¡ Priority 2: Mixed (White + Gray)',
                priority3: 'â—¾ Priority 3: GRAY Attributes Only',
                noDrills: 'Drills were not found',

                // View Attributes
                viewAttrTitle: 'Current Attributes',
                backToRecsBtn: 'â† Back to Recommendations',
                whitePrimary: 'â­ WHITE (Primary) Attributes',
                graySecondary: 'â—¾ GRAY (Secondary) Attributes',
                bonusIncluded: 'bonus included in WHITE attributes',
                base: 'base',

                // Update Attributes
                updateAttrTitle: 'Update Player Attributes',
                updateInstruction: 'Enter new values after training. Leave blank to keep current value.',
                saveBtn: 'Save & Recalculate âš¡',
                cancelBtn: 'â† Cancel',

                // Full Training Plan
                fullPlanTitle: 'Full Training Plan',
                planSummary: 'Plan Summary',
                currentRating: 'Current Rating:',
                targetRating: 'Target Rating:',
                totalDrills: 'Total Drills:',
                newRating: 'New Rating:',
                finalAttributes: 'Final Attributes',
                step: 'Step',
                trains: 'â†’',
                backToPlanRecsBtn: 'â† Back to Recommendations',
                roleLabel4: 'Role:',

                // Overall Rating
                overallRating: 'Overall Rating',
                overallBase: 'Base (no tier):',
                overallWithBonus: 'With tier bonus:',

                // Drill stats
                whiteAvg: 'White Avg:',
                grayAvg: 'Gray Avg:',
                overall: 'Overall:',
                potential: 'Potential:',
                whitePotential: 'White Potential:',
                grayPotential: 'Gray Potential:',
                white: 'WHITE:',
                gray: 'GRAY:',
                trains: 'â†’',

                // Category names
                attack: 'Attack',
                defense: 'Defense',
                physical: 'Physical & Mental',
                possession: 'Possession',

                // Difficulty levels
                difficulties: {
                    'VERY EASY': 'Very Easy',
                    'EASY': 'Easy',
                    'MEDIUM': 'Medium',
                    'HARD': 'Hard',
                    'VERY HARD': 'Very Hard'
                },

                // Attributes (English names)
                attrs: {
                    'Tackling': 'Tackling',
                    'Marking': 'Marking',
                    'Positioning': 'Positioning',
                    'Heading': 'Heading',
                    'Bravery': 'Bravery',
                    'Passing': 'Passing',
                    'Dribbling': 'Dribbling',
                    'Crossing': 'Crossing',
                    'Shooting': 'Shooting',
                    'Finishing': 'Finishing',
                    'Fitness': 'Fitness',
                    'Strength': 'Strength',
                    'Aggression': 'Aggression',
                    'Speed': 'Speed',
                    'Creativity': 'Creativity',
                    'Reflexes': 'Reflexes',
                    'Agility': 'Agility',
                    'Anticipation': 'Anticipation',
                    'Rushing out': 'Rushing out',
                    'Communication': 'Communication',
                    'Throwing': 'Throwing',
                    'Kicking': 'Kicking',
                    'Punching': 'Punching',
                    'Aerial reach': 'Aerial reach',
                    'Concentration': 'Concentration'
                },

                // Tiers (English names)
                tiers: {
                    'None': 'None',
                    'Rare': 'Rare',
                    'Elite': 'Elite',
                    'Stellar': 'Stellar',
                    'Master': 'Master',
                    'Epic': 'Epic',
                    'Legendary': 'Legendary'
                },

                // Drills (English names)
                drills: {
                    '1-on-1 Finishing': '1-on-1 Finishing',
                    'Pass, Go and Shoot!': 'Pass, Go and Shoot!',
                    'Set-Piece Delivery': 'Set-Piece Delivery',
                    'Shooting Technique': 'Shooting Technique',
                    'Slalom Dribble': 'Slalom Dribble',
                    'Wing Play': 'Wing Play',
                    'Fast Counter-Attacks': 'Fast Counter-Attacks',
                    'Video Analysis': 'Video Analysis',
                    'Use Your Head': 'Use Your Head',
                    'One Line of Defense': 'One Line of Defense',
                    'Stop the Attacker': 'Stop the Attacker',
                    'Defending Crosses': 'Defending Crosses',
                    'Press the Play': 'Press the Play',
                    'Goalkeeper Training': 'Goalkeeper Training',
                    'Warm-Up': 'Warm-Up',
                    'Stretch': 'Stretch',
                    'Carioca with Ladders': 'Carioca with Ladders',
                    'Long Run': 'Long Run',
                    'Shuttle Runs': 'Shuttle Runs',
                    'Hurdle Jumps': 'Hurdle Jumps',
                    'Gym': 'Gym',
                    'Sprint': 'Sprint',
                    'Ball Control': 'Ball Control',
                    'Piggy in the Middle': 'Piggy in the Middle',
                    'First Touch Play': 'First Touch Play',
                    'Rapid Side Switch': 'Rapid Side Switch',
                    'Stay in Lane': 'Stay in Lane',
                    'Contact Play': 'Contact Play',
                    'Passes Before Shot': 'Passes Before Shot'
                }
            }
        };

        function t(key) {
            const keys = key.split('.');
            let value = translations[currentLang];
            for (let k of keys) {
                value = value[k];
                if (!value) return key;
            }
            return value;
        }

        function toggleLanguage() {
            currentLang = currentLang === 'he' ? 'en' : 'he';
            document.documentElement.lang = currentLang;
            document.body.dir = currentLang === 'he' ? 'rtl' : 'ltr';
            document.querySelector('.lang-switcher').textContent = currentLang === 'he' ? 'English' : '×¢×‘×¨×™×ª';
            document.title = currentLang === 'he' ? '××—×©×‘×•×Ÿ ×œ××™××•× ×™×' : 'Football Training Optimizer';
            updateUILanguage();
        }

        function updateUILanguage() {
            // Update all static text elements
            document.getElementById('headerTitle').textContent = t('headerTitle');
            document.getElementById('headerSubtitle').textContent = t('headerSubtitle');
            document.getElementById('roleTitle').textContent = t('roleTitle');
            document.getElementById('roleInstruction').innerHTML = t('roleInstruction');
            document.getElementById('selectedPrefix').textContent = t('selectedPrefix');
            document.getElementById('continueBtn').textContent = t('continueBtn');
            document.getElementById('attrTitle').textContent = t('attrTitle');
            document.getElementById('roleLabel').textContent = t('roleLabel');
            document.getElementById('attrInstruction').textContent = t('attrInstruction');
            document.getElementById('getRecsBtn').textContent = t('getRecsBtn');
            document.getElementById('backBtn1').textContent = t('backBtn');
            document.getElementById('recsTitle').textContent = t('recsTitle');
            document.getElementById('roleLabel2').textContent = t('roleLabel');
            document.getElementById('updateBtn').textContent = t('updateBtn');
            document.getElementById('viewBtn').textContent = t('viewBtn');
            document.getElementById('startOverBtn').textContent = t('startOverBtn');
            document.getElementById('viewAttrTitle').textContent = t('viewAttrTitle');
            document.getElementById('roleLabel3').textContent = t('roleLabel');
            document.getElementById('backToRecsBtn').textContent = t('backToRecsBtn');
            document.getElementById('updateAttrTitle').textContent = t('updateAttrTitle');
            document.getElementById('updateInstruction').textContent = t('updateInstruction');
            document.getElementById('saveBtn').textContent = t('saveBtn');
            document.getElementById('cancelBtn').textContent = t('cancelBtn');
            document.getElementById('fullPlanBtn').textContent = t('fullPlanBtn');
            document.getElementById('betaWarning').textContent = t('betaWarning');
            document.getElementById('betaWarningText').textContent = t('betaWarningText');
            document.getElementById('fullPlanTitle').textContent = t('fullPlanTitle');
            document.getElementById('roleLabel4').textContent = t('roleLabel');
            document.getElementById('backToPlanRecsBtn').textContent = t('backToPlanRecsBtn');
            document.getElementById('filterPanelTitle').textContent = t('filterPanelTitle');

            // Re-render current section content if needed
            if (selectedRole) {
                document.getElementById('selectedRoleName').textContent = selectedRole;
                document.getElementById('recRoleName').textContent = selectedRole;
                document.getElementById('viewRoleName').textContent = selectedRole;
                document.getElementById('planRoleName').textContent = selectedRole;
            }
        }

        // Game data
        const REGULAR_ATTRIBUTES = [
            "Tackling", "Marking", "Positioning", "Heading", "Bravery",
            "Passing", "Dribbling", "Crossing", "Shooting", "Finishing",
            "Fitness", "Strength", "Aggression", "Speed", "Creativity"
        ];

        const GK_ATTRIBUTES = [
            "Reflexes", "Agility", "Anticipation", "Rushing out", "Communication",
            "Throwing", "Kicking", "Punching", "Aerial reach", "Concentration",
            "Fitness", "Strength", "Aggression", "Speed", "Creativity"
        ];

        const ROLE_WHITES = {
            "GK": ["Reflexes", "Agility", "Anticipation", "Rushing out", "Communication", "Throwing", "Kicking", "Punching", "Aerial reach", "Concentration", "Fitness"],
            "DL": ["Tackling", "Marking", "Positioning", "Bravery", "Crossing", "Fitness", "Aggression", "Speed"],
            "DC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Fitness", "Strength", "Aggression"],
            "DR": ["Tackling", "Marking", "Positioning", "Bravery", "Crossing", "Fitness", "Aggression", "Speed"],
            "DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Fitness", "Strength", "Aggression", "Creativity"],
            "ML": ["Positioning", "Passing", "Dribbling", "Crossing", "Fitness", "Speed", "Creativity"],
            "MC": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Shooting", "Fitness", "Speed", "Creativity"],
            "MR": ["Positioning", "Passing", "Dribbling", "Crossing", "Fitness", "Speed", "Creativity"],
            "AML": ["Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AMC": ["Heading", "Passing", "Dribbling", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AMR": ["Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "ST": ["Positioning", "Heading", "Passing", "Dribbling", "Shooting", "Finishing", "Strength", "Speed", "Creativity"],
            "DC + DL": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Crossing", "Fitness", "Strength", "Aggression", "Speed"],
            "DC + DR": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Crossing", "Fitness", "Strength", "Aggression", "Speed"],
            "DC + DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Fitness", "Strength", "Aggression", "Creativity"],
            "DL + ML": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Fitness", "Aggression", "Speed", "Creativity"],
            "DR + MR": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Fitness", "Aggression", "Speed", "Creativity"],
            "DMC + MC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Shooting", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "MC + ML": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Fitness", "Speed", "Creativity"],
            "MC + MR": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Fitness", "Speed", "Creativity"],
            "MC + AMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "ML + AML": ["Positioning", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MR + AMR": ["Positioning", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AMC + AML": ["Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AMC + AMR": ["Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AMC + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "AML + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "AMR + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "DL + DC + DR": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Crossing", "Fitness", "Strength", "Aggression", "Speed"],
            "DL + DC + DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DL + DC + ML": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DL + ML + AML": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Crossing", "Shooting", "Finishing", "Fitness", "Aggression", "Speed", "Creativity"],
            "DR + DC + DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DR + DC + MR": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DR + MR + AMR": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Aggression", "Speed", "Creativity"],
            "DC + DL + DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DC + DR + DMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Crossing", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DC + DMC + MC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Shooting", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DMC + MC + ML": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "DMC + MC + MR": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Fitness", "Strength", "Aggression", "Speed", "Creativity"],
            "MC + ML + AML": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MC + MR + AMR": ["Tackling", "Marking", "Positioning", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MC + AML + AMC": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MC + AMC + AMR": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MC + AMC + ST": ["Tackling", "Marking", "Positioning", "Heading", "Bravery", "Passing", "Dribbling", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "ML + AML + AMC": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "ML + AML + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "MR + AMR + AMC": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "MR + AMR + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "AML + AMC + AMR": ["Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Speed", "Creativity"],
            "AML + AMC + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "AMR + AMC + ST": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"],
            "AML + ST + AMR": ["Positioning", "Heading", "Passing", "Dribbling", "Crossing", "Shooting", "Finishing", "Fitness", "Strength", "Speed", "Creativity"]
        };

        const DRILLS = [
            ["1-on-1 Finishing", ["Tackling", "Anticipation", "Finishing", "Dribbling", "Rushing out"], "EASY", "attack"],
            ["Pass, Go and Shoot!", ["Anticipation", "Speed", "Shooting", "Passing"], "EASY", "attack"],
            ["Set-Piece Delivery", ["Crossing", "Rushing out", "Heading", "Shooting", "Marking"], "MEDIUM", "attack"],
            ["Shooting Technique", ["Agility", "Reflexes", "Finishing", "Strength", "Shooting"], "MEDIUM", "attack"],
            ["Slalom Dribble", ["Speed", "Dribbling", "Fitness", "Passing"], "HARD", "attack"],
            ["Wing Play", ["Crossing", "Punching", "Finishing", "Heading", "Shooting"], "HARD", "attack"],
            ["Fast Counter-Attacks", ["Crossing", "Finishing", "Passing", "Creativity", "Communication"], "VERY HARD", "attack"],
            ["Video Analysis", ["Bravery", "Creativity", "Communication", "Positioning"], "VERY EASY", "defense"],
            ["Use Your Head", ["Creativity", "Passing", "Heading", "Positioning"], "EASY", "defense"],
            ["One Line of Defense", ["Concentration", "Communication", "Marking", "Positioning"], "MEDIUM", "defense"],
            ["Stop the Attacker", ["Tackling", "Bravery", "Dribbling", "Strength", "Marking"], "MEDIUM", "defense"],
            ["Defending Crosses", ["Crossing", "Bravery", "Heading", "Aerial reach", "Marking"], "MEDIUM", "defense"],
            ["Press the Play", ["Tackling", "Bravery", "Positioning", "Aggression", "Marking"], "HARD", "defense"],
            ["Goalkeeper Training", ["Kicking", "Agility", "Reflexes", "Throwing", "Aerial reach"], "HARD", "defense"],
            ["Warm-Up", ["Fitness", "Reflexes", "Heading", "Aggression"], "VERY EASY", "physical"],
            ["Stretch", ["Speed", "Agility", "Fitness", "Strength"], "EASY", "physical"],
            ["Carioca with Ladders", ["Speed", "Agility", "Concentration", "Aggression"], "EASY", "physical"],
            ["Long Run", ["Fitness", "Speed", "Concentration"], "MEDIUM", "physical"],
            ["Shuttle Runs", ["Speed", "Bravery", "Agility", "Strength"], "HARD", "physical"],
            ["Hurdle Jumps", ["Speed", "Bravery", "Kicking", "Aggression"], "HARD", "physical"],
            ["Gym", ["Fitness", "Kicking", "Throwing", "Strength"], "VERY HARD", "physical"],
            ["Sprint", ["Speed", "Dribbling", "Fitness", "Rushing out"], "VERY HARD", "physical"],
            ["Ball Control", ["Dribbling", "Creativity", "Concentration", "Heading"], "VERY EASY", "possession"],
            ["Piggy in the Middle", ["Tackling", "Fitness", "Positioning", "Passing", "Aggression"], "EASY", "possession"],
            ["First Touch Play", ["Dribbling", "Fitness", "Passing", "Throwing"], "EASY", "possession"],
            ["Rapid Side Switch", ["Positioning", "Creativity", "Communication", "Crossing", "Passing", "Speed"], "MEDIUM", "possession"],
            ["Stay in Lane", ["Speed", "Fitness", "Aerial reach", "Positioning"], "MEDIUM", "possession"],
            ["Contact Play", ["Bravery", "Dribbling", "Strength", "Aggression", "Marking"], "MEDIUM", "possession"],
            ["Passes Before Shot", ["Anticipation", "Finishing", "Positioning", "Passing", "Creativity"], "HARD", "possession"]
        ];

        const PLAYER_TIERS = {
            "None": 0,
            "Rare": 10,
            "Elite": 30,
            "Stellar": 50,
            "Master": 80,
            "Epic": 120,
            "Legendary": 160
        };

        const EFFECTIVENESS_THRESHOLD = 179.5;

        let selectedRole = null;
        let playerStats = {};
        let playerTier = "None";

        // Cached drill lists for filter re-rendering
        let cachedWhiteDrills = [];
        let cachedMixedDrills = [];
        let cachedGrayDrills = [];

        function initRoleGrid() {
            const roleGrid = document.getElementById('roleGrid');
            const roles = Object.keys(ROLE_WHITES);

            roles.forEach(role => {
                const btn = document.createElement('div');
                btn.className = 'role-btn';
                btn.textContent = role;
                btn.onclick = () => selectRole(role);
                roleGrid.appendChild(btn);
            });
        }

        function selectRole(role) {
            selectedRole = role;

            document.querySelectorAll('.role-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.textContent === role) {
                    btn.classList.add('selected');
                }
            });

            document.getElementById('selectedRoleBox').classList.add('show');
            document.getElementById('selectedRoleText').textContent = role;
        }

        function continueToAttributes() {
            if (!selectedRole) {
                alert(currentLang === 'he' ? 'âš ï¸ ×× × ×‘×—×¨ ×ª×¤×§×™×“ ×ª×—×™×œ×”!\n\n×œ×—×¥ ×¢×œ ××—×“ ××›×¤×ª×•×¨×™ ×”×ª×¤×§×™×“ (×›××• ST, GK, DC ×•×›×•\') ×›×“×™ ×œ×‘×—×•×¨ ××•×ª×•.' : 'âš ï¸ Please select a role first!\n\nTap on one of the role buttons (like ST, GK, DC, etc.) to select it.');
                return;
            }

            showSection('attributesSection');
            document.getElementById('selectedRoleName').textContent = selectedRole;
            initAttributesForm();
        }

        function initAttributesForm() {
            const form = document.getElementById('attributesForm');
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);

            form.innerHTML = '';

            const tierGroup = document.createElement('div');
            tierGroup.style.marginBottom = '20px';
            tierGroup.innerHTML = `
                <div class="form-group">
                    <label style="font-size: 16px; color: #667eea;">${t('playerTierLabel')}</label>
                    <select id="playerTier" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px;">
                        ${Object.keys(PLAYER_TIERS).map(tier =>
                            `<option value="${tier}" ${tier === playerTier ? 'selected' : ''}>${t('tiers.' + tier)} (+${PLAYER_TIERS[tier]})</option>`
                        ).join('')}
                    </select>
                </div>
            `;
            form.appendChild(tierGroup);

            const grid = document.createElement('div');
            grid.className = 'attr-grid';

            // Create 3 columns with 5 attributes each
            for (let col = 0; col < 3; col++) {
                const column = document.createElement('div');

                const startIdx = col * 5;
                const endIdx = startIdx + 5;

                for (let i = startIdx; i < endIdx && i < attributes.length; i++) {
                    const attr = attributes[i];
                    const isWhite = whiteAttrs.has(attr);
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    formGroup.innerHTML = `
                        <label>${t('attrs.' + attr)} ${isWhite ? 'â­' : ''}</label>
                        <input type="number" id="attr_${attr}" min="0" value="${playerStats[attr] || ''}" required>
                    `;
                    column.appendChild(formGroup);
                }

                grid.appendChild(column);
            }

            form.appendChild(grid);

            const infoBox = document.createElement('div');
            infoBox.style.background = '#e7f3ff';
            infoBox.style.border = '2px solid #2196F3';
            infoBox.style.borderRadius = '8px';
            infoBox.style.padding = '12px';
            infoBox.style.marginTop = '15px';
            infoBox.style.fontSize = '13px';
            infoBox.style.color = '#0d47a1';
            infoBox.innerHTML = t('tierNote');
            form.appendChild(infoBox);
        }

        function calculateRecommendations() {
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            let hasError = false;

            playerTier = document.getElementById('playerTier').value;

            attributes.forEach(attr => {
                const value = parseInt(document.getElementById(`attr_${attr}`).value);
                if (isNaN(value) || value < 0) {
                    alert((currentLang === 'he' ? '×× × ×”×–×Ÿ ×¢×¨×š ×—×•×§×™ ×¢×‘×•×¨ ' : 'Please enter a valid value for ') + t('attrs.' + attr));
                    hasError = true;
                    return;
                }
                playerStats[attr] = value;
            });

            if (hasError) return;

            showSection('recommendationsSection');
            document.getElementById('recRoleName').textContent = selectedRole;
            displayRecommendations();
        }

        function displayRecommendations() {
            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);
            const whiteDrills = [];
            const mixedDrills = [];
            const grayDrills = [];
            const ineffective = [];

            DRILLS.forEach(([name, attrs, difficulty, category]) => {
                const analysis = analyzeDrill(attrs, whiteAttrs);
                if (!analysis.overallAvg) return;

                const drill = {
                    name, attrs, difficulty, category,
                    ...analysis,
                    potential: EFFECTIVENESS_THRESHOLD - analysis.overallAvg
                };

                // Check if NEXT drill would push drill's attributes average beyond 179.5
                const tierBonus = PLAYER_TIERS[playerTier];
                const statsAfterDrill = { ...playerStats };
                for (const attr of attrs) {
                    if (attr in statsAfterDrill) {
                        statsAfterDrill[attr] += 1;
                    }
                }

                // Calculate drill's attributes average AFTER doing the drill
                let drillSumAfter = 0;
                let drillCountAfter = 0;
                for (const attr of attrs) {
                    if (attr in statsAfterDrill) {
                        const value = whiteAttrs.has(attr) ? statsAfterDrill[attr] - tierBonus : statsAfterDrill[attr];
                        drillSumAfter += value;
                        drillCountAfter++;
                    }
                }
                const drillAvgAfter = drillCountAfter > 0 ? drillSumAfter / drillCountAfter : null;

                if (drillAvgAfter && drillAvgAfter > 179.5) {
                    ineffective.push(drill);
                } else {
                    // Check if drill would push PLAYER'S OVERALL RATING above 179.5
                    const tierBonus = PLAYER_TIERS[playerTier];
                    const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
                    const statsAfter = { ...playerStats };

                    // Simulate drill effect
                    for (const attr of attrs) {
                        if (attr in statsAfter) {
                            statsAfter[attr] += 1; // +1 for both white and gray (gray +0.5 rounds up to 1)
                        }
                    }

                    const ratingAfter = calculateOverallRatingWithStats(whiteAttrs, tierBonus, statsAfter, attributes).base;

                    if (ratingAfter > 179.5) {
                        // Drill would push overall rating above 179.5, mark as ineffective
                        ineffective.push(drill);
                    } else if (analysis.whiteAttrs.length > 0 && analysis.grayAttrs.length === 0) {
                        whiteDrills.push(drill);
                    } else if (analysis.grayAttrs.length > 0 && analysis.whiteAttrs.length === 0) {
                        grayDrills.push(drill);
                    } else {
                        mixedDrills.push(drill);
                    }
                }
            });

            whiteDrills.sort((a, b) => a.whiteAvg - b.whiteAvg);
            mixedDrills.sort((a, b) => {
                if (b.whiteAttrs.length !== a.whiteAttrs.length) {
                    return b.whiteAttrs.length - a.whiteAttrs.length;
                }
                if (a.whiteAvg !== b.whiteAvg) {
                    return a.whiteAvg - b.whiteAvg;
                }
                return b.grayAvg - a.grayAvg;
            });
            grayDrills.sort((a, b) => b.grayAvg - a.grayAvg);

            const tierBonus = PLAYER_TIERS[playerTier];
            const overallRating = calculateOverallRating(whiteAttrs, tierBonus);

            const summaryBox = document.getElementById('summaryBox');
            summaryBox.innerHTML = `
                <h3>ğŸ“Š ${t('summary')}</h3>
                <div style="font-size: 14px; line-height: 1.8;">
                    <div><strong>${t('playerTier')}</strong> ${t('tiers.' + playerTier)} (+${tierBonus} ${t('tierIncluded')})</div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">${t('tierSubtracted')}</div>
                    <div style="margin-top: 10px; padding: 10px; background: #e7f3ff; border-radius: 6px; border: 2px solid #2196F3;">
                        <strong style="color: #0d47a1;">âš½ ${t('overallRating')}</strong><br>
                        <span style="font-size: 13px;">
                            ${t('overallBase')} <strong>${overallRating.base.toFixed(2)}</strong><br>
                            ${t('overallWithBonus')} <strong style="color: #667eea;">${overallRating.withBonus.toFixed(2)}</strong>
                        </span>
                    </div>
                    <div style="margin-top: 10px;"><strong>${t('effectiveDrills')}</strong> ${whiteDrills.length + mixedDrills.length + grayDrills.length}</div>
                    <div style="color: #28a745;">â–ª ${t('whiteOnly')} ${whiteDrills.length}</div>
                    <div style="color: #ffc107;">â–ª ${t('mixed')} ${mixedDrills.length}</div>
                    <div style="color: #6c757d;">â–ª ${t('grayOnly')} ${grayDrills.length}</div>
                    <div style="margin-top: 10px;"><strong>${t('ineffective')}</strong> ${ineffective.length}</div>
                </div>
                <div class="category-legend">
                    <div class="legend-item"><div class="legend-color" style="background:#dc3545;"></div> ${t('attack')}</div>
                    <div class="legend-item"><div class="legend-color" style="background:#28a745;"></div> ${t('defense')}</div>
                    <div class="legend-item"><div class="legend-color" style="background:#6f42c1;"></div> ${t('physical')}</div>
                    <div class="legend-item"><div class="legend-color" style="background:#fd7e14;"></div> ${t('possession')}</div>
                </div>
            `;

            // Cache drill lists and build filter
            cachedWhiteDrills = whiteDrills;
            cachedMixedDrills = mixedDrills;
            cachedGrayDrills = grayDrills;
            buildFilterCheckboxes();
            renderDrillList();
        }

        function analyzeDrill(drillAttrs, whiteAttrs) {
            const whiteInDrill = [];
            const grayInDrill = [];
            const whiteValues = [];
            const grayValues = [];
            const whiteValuesWithBonus = []; // For display
            const tierBonus = PLAYER_TIERS[playerTier];

            drillAttrs.forEach(attr => {
                if (!(attr in playerStats)) return;

                if (whiteAttrs.has(attr)) {
                    whiteInDrill.push(attr);
                    const baseValue = playerStats[attr] - tierBonus;
                    whiteValues.push(baseValue);
                    whiteValuesWithBonus.push(playerStats[attr]); // Store actual value for display
                } else {
                    grayInDrill.push(attr);
                    grayValues.push(playerStats[attr]);
                }
            });

            const whiteAvg = whiteValues.length > 0 ? whiteValues.reduce((a, b) => a + b, 0) / whiteValues.length : null;
            const whiteAvgDisplay = whiteValuesWithBonus.length > 0 ? whiteValuesWithBonus.reduce((a, b) => a + b, 0) / whiteValuesWithBonus.length : null;
            const grayAvg = grayValues.length > 0 ? grayValues.reduce((a, b) => a + b, 0) / grayValues.length : null;
            const allValues = [...whiteValues, ...grayValues];
            const overallAvg = allValues.length > 0 ? allValues.reduce((a, b) => a + b, 0) / allValues.length : null;

            // Calculate weighted potential based on 2:1 growth ratio (whites +2, grays +1)
            const totalGrowthParts = (whiteInDrill.length * 2) + (grayInDrill.length * 1);
            const totalPotential = overallAvg !== null ? EFFECTIVENESS_THRESHOLD - overallAvg : 0;
            const whitePotential = totalGrowthParts > 0 ? (whiteInDrill.length * 2 / totalGrowthParts) * totalPotential : 0;
            const grayPotential = totalGrowthParts > 0 ? (grayInDrill.length * 1 / totalGrowthParts) * totalPotential : 0;

            return { whiteAttrs: whiteInDrill, grayAttrs: grayInDrill, whiteAvg, whiteAvgDisplay, grayAvg, overallAvg, whitePotential, grayPotential, totalPotential };
        }

        function calculateOverallRating(whiteAttrs, tierBonus) {
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            let totalSumWithBonus = 0;  // Sum of input values (with tier already in whites)
            let totalSumBase = 0;       // Sum after removing tier from whites
            let count = 0;

            attributes.forEach(attr => {
                if (attr in playerStats) {
                    totalSumWithBonus += playerStats[attr];

                    if (whiteAttrs.has(attr)) {
                        // White attributes: subtract tier bonus to get base
                        totalSumBase += playerStats[attr] - tierBonus;
                    } else {
                        // Gray attributes: no tier bonus, use as-is
                        totalSumBase += playerStats[attr];
                    }
                    count++;
                }
            });

            const base = count > 0 ? totalSumBase / count : 0;
            const withBonus = count > 0 ? totalSumWithBonus / count : 0;

            return { base, withBonus };
        }

        function createDrillCard(drill, type) {
            const card = document.createElement('div');
            card.className = `drill-card ${type} category-${drill.category}`;

            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);
            const tierBonus = PLAYER_TIERS[playerTier];

            // Calculate ACTUAL potential that brings average to 179.5 (with safety checks)
            let actualWhitePotentialInt = 0;
            let actualGrayPotentialInt = 0;

            if (drill.whiteAttrs && drill.grayAttrs && playerStats && Object.keys(playerStats).length > 0) {
                let whiteCount = drill.whiteAttrs.length;
                let grayCount = drill.grayAttrs.length;
                let whiteBaseSum = 0;
                let grayBaseSum = 0;

                drill.whiteAttrs.forEach(attr => {
                    if (attr in playerStats) {
                        whiteBaseSum += playerStats[attr] - tierBonus;
                    }
                });

                drill.grayAttrs.forEach(attr => {
                    if (attr in playerStats) {
                        grayBaseSum += playerStats[attr];
                    }
                });

                const totalAttrs = whiteCount + grayCount;
                if (totalAttrs > 0) {
                    const initialCalc = (EFFECTIVENESS_THRESHOLD * totalAttrs - whiteBaseSum - grayBaseSum) / (whiteCount + grayCount / 2);
                    let testWhite = Math.floor(initialCalc);

                    // Iterate to find max white that keeps avg <= 179.5
                    let testAvg;
                    do {
                        const testGray = Math.ceil(testWhite / 2); // Gray is always ceil(white/2)
                        testAvg = (whiteBaseSum + whiteCount * testWhite + grayBaseSum + grayCount * testGray) / totalAttrs;

                        if (testAvg > EFFECTIVENESS_THRESHOLD && testWhite > 0) {
                            testWhite--;
                        } else {
                            actualWhitePotentialInt = testWhite;
                            actualGrayPotentialInt = testGray;
                            break;
                        }
                    } while (testWhite > 0);
                }
            }

            let statsHtml = '';
            if (type === 'white') {
                // Show base average (without bonus) to match potential calculation
                const baseAvgNote = tierBonus > 0 ? ` (${currentLang === 'he' ? '×××•×¦×¢ ×¢× ×‘×•× ×•×¡' : 'avg with bonus'}: ${drill.whiteAvgDisplay.toFixed(1)})` : '';
                const potentialToShow = actualWhitePotentialInt > 0 ? actualWhitePotentialInt : drill.whitePotential.toFixed(1);
                statsHtml = `${t('whiteAvg')} ${drill.whiteAvg.toFixed(1)}${baseAvgNote} | ${t('potential')} +${potentialToShow}`;
            } else if (type === 'mixed') {
                const baseAvgNote = tierBonus > 0 && drill.whiteAvg ? ` (${currentLang === 'he' ? '×¢× ×‘×•× ×•×¡' : 'w/bonus'}: ${drill.whiteAvgDisplay.toFixed(1)})` : '';
                const whiteStr = drill.whiteAvg ? `${t('white')} ${drill.whiteAvg.toFixed(1)}${baseAvgNote}` : '';
                const grayStr = drill.grayAvg ? `${t('gray')} ${drill.grayAvg.toFixed(1)}` : '';
                // Show ACTUAL potentials being applied
                const whitePotentialToShow = actualWhitePotentialInt > 0 ? actualWhitePotentialInt : drill.whitePotential.toFixed(1);
                const grayPotentialToShow = actualGrayPotentialInt > 0 ? actualGrayPotentialInt : Math.ceil(drill.whitePotential / 2); // Ceiling for gray
                statsHtml = `${whiteStr} | ${grayStr} | ${t('whitePotential')} +${whitePotentialToShow} | ${t('grayPotential')} +${grayPotentialToShow}`;
            } else {
                const grayPotentialToShow = actualGrayPotentialInt > 0 ? actualGrayPotentialInt : drill.grayPotential.toFixed(1);
                statsHtml = `${t('grayAvg')} ${drill.grayAvg.toFixed(1)} | ${t('overall')} ${drill.overallAvg.toFixed(1)} | ${t('potential')} +${grayPotentialToShow}`;
            }

            // Calculate attribute changes - calculate potential to reach 179.5 average
            let changesHtml = '<div style="margin-top: 10px; padding: 10px; background: rgba(102, 126, 234, 0.08); border-radius: 6px; font-size: 12px;">';
            changesHtml += '<div style="font-weight: 600; margin-bottom: 6px; color: #667eea;">' + (currentLang === 'he' ? '×©×™× ×•×™×™× ×‘×××¤×™×™× ×™×:' : 'Attribute Changes:') + '</div>';

            const allAttrs = [...drill.whiteAttrs, ...drill.grayAttrs];
            let totalFinalBase = 0;
            let attrCount = 0;

            // Calculate potential to bring average to 179.5, considering 2:1 growth ratio
            let whiteCount = drill.whiteAttrs.length;
            let grayCount = drill.grayAttrs.length;
            let whiteBaseSum = 0;
            let grayBaseSum = 0;

            drill.whiteAttrs.forEach(attr => {
                if (attr in playerStats) {
                    whiteBaseSum += playerStats[attr] - tierBonus;
                }
            });

            drill.grayAttrs.forEach(attr => {
                if (attr in playerStats) {
                    grayBaseSum += playerStats[attr];
                }
            });

            // Solve for white potential accounting for ceiling on gray
            // We need: (whiteBaseSum + W*x + grayBaseSum + G*ceil(x/2)) / (W + G) = 179.5
            const totalAttrs = whiteCount + grayCount;
            let whitePotentialInt = 0;
            let grayPotentialInt = 0;

            if (totalAttrs > 0) {
                // Calculate assuming floor/2 for gray
                const initialCalc = (EFFECTIVENESS_THRESHOLD * totalAttrs - whiteBaseSum - grayBaseSum) / (whiteCount + grayCount / 2);
                let testWhite = Math.floor(initialCalc);

                // Iterate to find max white that keeps avg <= 179.5
                let testAvg;
                do {
                    const testGray = Math.ceil(testWhite / 2); // Gray is always ceil(white/2)
                    testAvg = (whiteBaseSum + whiteCount * testWhite + grayBaseSum + grayCount * testGray) / totalAttrs;

                    if (testAvg > EFFECTIVENESS_THRESHOLD && testWhite > 0) {
                        testWhite--;
                    } else {
                        whitePotentialInt = testWhite;
                        grayPotentialInt = testGray;
                        break;
                    }
                } while (testWhite > 0);
            }

            allAttrs.forEach(attr => {
                const current = playerStats[attr];
                const isWhite = whiteAttrs.has(attr);
                const currentBase = isWhite ? current - tierBonus : current;

                // Use calculated potential
                const potentialInt = isWhite ? whitePotentialInt : grayPotentialInt;
                const finalValue = current + potentialInt;
                const finalBase = currentBase + potentialInt;

                totalFinalBase += finalBase;
                attrCount++;

                changesHtml += `<div style="margin-bottom: 3px; color: ${isWhite ? '#28a745' : '#6c757d'}; font-weight: ${isWhite ? '600' : '400'};">`;
                changesHtml += `${t('attrs.' + attr)}${isWhite ? ' â­' : ''}: ${current} + ${potentialInt} = ${finalValue}`;
                changesHtml += '</div>';
            });

            // Calculate total leftover
            const avgFinalBase = attrCount > 0 ? totalFinalBase / attrCount : 0;
            const totalLeftover = EFFECTIVENESS_THRESHOLD - avgFinalBase;

            // Calculate EXACT total points (integers only) that can be added to reach 179.5
            const targetTotal = EFFECTIVENESS_THRESHOLD * attrCount;
            const currentTotal = totalFinalBase;
            const totalPointsToAdd = Math.ceil(targetTotal - currentTotal);

            changesHtml += '<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #667eea; font-weight: 600; color: #667eea;">';
            changesHtml += `${currentLang === 'he' ? '×¡×”×´×› × ×•×ª×¨' : 'TOTAL Leftover'}: 179.5 - ${avgFinalBase.toFixed(1)} = ${totalLeftover.toFixed(1)}`;
            changesHtml += '<br>';
            changesHtml += `<span style="font-size: 11px; font-weight: 500;">${currentLang === 'he' ? '×¡×”×´×› × ×§×•×“×•×ª ×©× ×™×ª×Ÿ ×œ×”×•×¡×™×£:' : 'Total points to add:'} ${totalPointsToAdd}</span>`;
            changesHtml += '</div>';

            changesHtml += '</div>';

            // Calculate leftover to average using BASE values (without tier bonus for whites)
            let totalSum = 0;
            let totalCount = 0;
            allAttrs.forEach(attr => {
                if (attr in playerStats) {
                    const isWhite = whiteAttrs.has(attr);
                    // Use base value for whites (subtract tier bonus)
                    const baseValue = isWhite ? playerStats[attr] - tierBonus : playerStats[attr];
                    totalSum += baseValue;
                    totalCount++;
                }
            });
            const totalAvg = totalCount > 0 ? totalSum / totalCount : 0;
            const leftover = EFFECTIVENESS_THRESHOLD - totalAvg;

            let leftoverHtml = '<div style="margin-top: 12px; margin-bottom: 12px; padding: 8px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; font-size: 12px;">';
            if (currentLang === 'he') {
                leftoverHtml = '<div style="margin-top: 12px; margin-bottom: 12px; padding: 8px; background: #fff3cd; border-right: 4px solid #ffc107; border-radius: 4px; font-size: 12px;">';
            }
            leftoverHtml += `<strong>${currentLang === 'he' ? '×××•×¦×¢ × ×•×›×—×™ ×©×œ ×”×ª×¨×’×™×œ:' : 'Current drill avg:'}</strong> <span style="color: #856404; font-weight: 600;">${totalAvg.toFixed(1)}</span> | `;
            leftoverHtml += `<strong>${currentLang === 'he' ? '× ×•×ª×¨ ×¢×“ 179.5:' : 'Left to 179.5:'}</strong> <span style="color: #856404; font-weight: 600;">${leftover.toFixed(1)}</span>`;
            leftoverHtml += '</div>';

            let attrsHtml = '';
            if (type === 'white') {
                attrsHtml = `${t('trains')} ${drill.whiteAttrs.map(a => t('attrs.' + a)).join(', ')}`;
            } else if (type === 'mixed') {
                attrsHtml = `<div>${t('trains')} ${t('white')} ${drill.whiteAttrs.map(a => t('attrs.' + a)).join(', ')}</div>`;
                attrsHtml += `<div>${t('trains')} ${t('gray')} ${drill.grayAttrs.map(a => t('attrs.' + a)).join(', ')}</div>`;
            } else {
                attrsHtml = `${t('trains')} ${drill.grayAttrs.map(a => t('attrs.' + a)).join(', ')}`;
            }

            card.innerHTML = `
                <h3>
                    ${t('drills.' + drill.name)}
                    <span class="badge badge-category badge-${drill.category}">${t(drill.category)}</span>
                    <span class="badge badge-difficulty">${t('difficulties.' + drill.difficulty)}</span>
                </h3>
                ${leftoverHtml}
                <div class="drill-stats">${statsHtml}</div>
                <div class="drill-attrs">${attrsHtml}</div>
                ${changesHtml}
            `;

            return card;
        }

        function updateAttributes() {
            showSection('updateSection');
            const form = document.getElementById('updateForm');
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);

            form.innerHTML = '';

            const tierGroup = document.createElement('div');
            tierGroup.style.marginBottom = '20px';
            tierGroup.innerHTML = `
                <div class="form-group">
                    <label style="font-size: 16px; color: #667eea;">${t('playerTierLabel')}</label>
                    <select id="updatePlayerTier" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px;">
                        ${Object.keys(PLAYER_TIERS).map(tier =>
                            `<option value="${tier}" ${tier === playerTier ? 'selected' : ''}>${t('tiers.' + tier)} (+${PLAYER_TIERS[tier]})</option>`
                        ).join('')}
                    </select>
                </div>
            `;
            form.appendChild(tierGroup);

            const grid = document.createElement('div');
            grid.className = 'attr-grid';

            // Create 3 columns with 5 attributes each
            for (let col = 0; col < 3; col++) {
                const column = document.createElement('div');

                const startIdx = col * 5;
                const endIdx = startIdx + 5;

                for (let i = startIdx; i < endIdx && i < attributes.length; i++) {
                    const attr = attributes[i];
                    const isWhite = whiteAttrs.has(attr);
                    const current = playerStats[attr];
                    const formGroup = document.createElement('div');
                    formGroup.className = 'form-group';
                    formGroup.innerHTML = `
                        <label>${t('attrs.' + attr)} ${isWhite ? 'â­' : ''} <span style="color: #999; font-size: 12px;">(${current})</span></label>
                        <input type="number" id="update_${attr}" min="0" placeholder="${currentLang === 'he' ? '×”×©××¨ ×¨×™×§ = ' + current : 'Leave blank = ' + current}">
                    `;
                    column.appendChild(formGroup);
                }

                grid.appendChild(column);
            }

            form.appendChild(grid);
        }

        function saveUpdates() {
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            let updated = false;

            const newTier = document.getElementById('updatePlayerTier').value;
            if (newTier !== playerTier) {
                playerTier = newTier;
                updated = true;
            }

            attributes.forEach(attr => {
                const input = document.getElementById(`update_${attr}`);
                const value = input.value.trim();
                if (value !== '') {
                    const num = parseInt(value);
                    if (!isNaN(num) && num >= 0) {
                        playerStats[attr] = num;
                        updated = true;
                    }
                }
            });

            if (updated) {
                showSection('recommendationsSection');
                displayRecommendations();
            } else {
                alert(currentLang === 'he' ? '×œ× ×‘×•×¦×¢×• ×©×™× ×•×™×™×. ×”×–×Ÿ ×œ×¤×—×•×ª ×¢×¨×š ×—×“×© ××—×“ ××• ×©× ×” ×“×¨×’×”.' : 'No changes made. Enter at least one new value or change tier.');
            }
        }

        function viewAttributes() {
            showSection('viewAttributesSection');
            document.getElementById('viewRoleName').textContent = selectedRole;

            const display = document.getElementById('attributesDisplay');
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);
            const tierBonus = PLAYER_TIERS[playerTier];
            const overallRating = calculateOverallRating(whiteAttrs, tierBonus);

            let html = '<div class="attributes-display">';

            if (tierBonus > 0) {
                html += `<div style="background: #e7f3ff; border: 2px solid #2196F3; border-radius: 8px; padding: 12px; margin-bottom: 15px; font-size: 14px; color: #0d47a1;">
                    <strong>${t('playerTier')}</strong> ${t('tiers.' + playerTier)} (+${tierBonus} ${t('bonusIncluded')})
                </div>`;
            }

            html += `<div style="background: #e7f3ff; border: 2px solid #2196F3; border-radius: 8px; padding: 12px; margin-bottom: 15px; font-size: 14px; color: #0d47a1;">
                <strong>âš½ ${t('overallRating')}</strong><br>
                <span style="font-size: 13px;">
                    ${t('overallBase')} <strong>${overallRating.base.toFixed(2)}</strong><br>
                    ${t('overallWithBonus')} <strong style="color: #667eea;">${overallRating.withBonus.toFixed(2)}</strong>
                </span>
            </div>`;

            html += `<h4>${t('whitePrimary')}</h4>`;
            attributes.forEach(attr => {
                if (whiteAttrs.has(attr)) {
                    const totalValue = playerStats[attr];
                    const baseValue = totalValue - tierBonus;
                    const bonusText = tierBonus > 0 ? ` <span style="color: #2196F3; font-size: 12px;">(${baseValue} ${t('base')} + ${tierBonus})</span>` : '';
                    html += `<div class="attr-item white"><span>${t('attrs.' + attr)}</span><strong>${totalValue}${bonusText}</strong></div>`;
                }
            });

            html += `<h4 style="margin-top: 20px;">${t('graySecondary')}</h4>`;
            attributes.forEach(attr => {
                if (!whiteAttrs.has(attr)) {
                    html += `<div class="attr-item gray"><span>${t('attrs.' + attr)}</span><strong>${playerStats[attr]}</strong></div>`;
                }
            });
            html += '</div>';

            display.innerHTML = html;
        }

        function generateFullPlan() {
            showSection('fullPlanSection');
            document.getElementById('planRoleName').textContent = selectedRole;

            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);
            const tierBonus = PLAYER_TIERS[playerTier];
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            const TARGET_RATING = 180;
            const GRAY_CAP = 120; // Increased from 110 to 120

            // Clone current stats for simulation
            let simulatedStats = { ...playerStats };
            // Track fractional parts for gray attributes (they grow by +0.5 per drill)
            let grayFractional = {};
            attributes.forEach(attr => {
                if (!whiteAttrs.has(attr) && attr in simulatedStats) {
                    grayFractional[attr] = 0;
                }
            });
            let currentOverall = calculateOverallRating(whiteAttrs, tierBonus).base;
            const steps = [];
            const MAX_STEPS = 2000; // Increased from 500 to 2000

            // Simple greedy: train lowest white, prefer drills with fewer grays
            while (currentOverall < TARGET_RATING && steps.length < MAX_STEPS) {
                let bestDrill = null;
                let bestMinWhite = Infinity;
                let bestGrayCount = Infinity;

                for (const [name, attrs, difficulty, category] of DRILLS) {
                    // Separate whites and grays
                    const whiteInDrill = [];
                    const grayInDrill = [];
                    for (const attr of attrs) {
                        if (attr in simulatedStats) {
                            if (whiteAttrs.has(attr)) whiteInDrill.push(attr);
                            else grayInDrill.push(attr);
                        }
                    }

                    if (whiteInDrill.length === 0) continue; // Must train at least one white

                    // Skip if any gray is >= 120
                    let hasHighGray = false;
                    for (const attr of grayInDrill) {
                        if (simulatedStats[attr] >= GRAY_CAP) {
                            hasHighGray = true;
                            break;
                        }
                    }
                    if (hasHighGray) continue;

                    // Check if NEXT drill would push drill's attributes average beyond 179.5
                    const statsAfterNextDrill = { ...simulatedStats };
                    for (const attr of attrs) {
                        if (attr in statsAfterNextDrill) {
                            if (whiteAttrs.has(attr)) {
                                statsAfterNextDrill[attr] += 1;
                            } else {
                                statsAfterNextDrill[attr] += 1;
                            }
                        }
                    }

                    let drillSumAfter = 0;
                    let drillCountAfter = 0;
                    for (const attr of attrs) {
                        if (attr in statsAfterNextDrill) {
                            const value = whiteAttrs.has(attr) ? statsAfterNextDrill[attr] - tierBonus : statsAfterNextDrill[attr];
                            drillSumAfter += value;
                            drillCountAfter++;
                        }
                    }
                    if (drillCountAfter === 0) continue;
                    const drillAvgAfter = drillSumAfter / drillCountAfter;
                    if (drillAvgAfter > 179.5) continue; // Drill would push its attributes beyond 179.5

                    // Check if drill would push PLAYER'S OVERALL RATING above 179.5
                    const statsAfterDrill = { ...simulatedStats };
                    for (const attr of attrs) {
                        if (attr in statsAfterDrill) {
                            if (whiteAttrs.has(attr)) {
                                statsAfterDrill[attr] += 1;
                            } else {
                                statsAfterDrill[attr] += 1; // Gray +0.5 rounds up to 1
                            }
                        }
                    }
                    const overallAfterDrill = calculateOverallRatingWithStats(whiteAttrs, tierBonus, statsAfterDrill, attributes).base;
                    if (overallAfterDrill > 179.5) continue; // Would push overall above 179.5, skip this drill

                    // Find minimum white value
                    let minWhite = Infinity;
                    for (const attr of whiteInDrill) {
                        const baseValue = simulatedStats[attr] - tierBonus;
                        if (baseValue < minWhite) minWhite = baseValue;
                    }

                    // Selection: lowest min white, then FEWEST grays
                    if (minWhite < bestMinWhite) {
                        bestMinWhite = minWhite;
                        bestGrayCount = grayInDrill.length;
                        bestDrill = { name, attrs, difficulty, category, whiteInDrill, grayInDrill };
                    } else if (minWhite === bestMinWhite && grayInDrill.length < bestGrayCount) {
                        // Same min white: prefer drill with fewer grays
                        bestGrayCount = grayInDrill.length;
                        bestDrill = { name, attrs, difficulty, category, whiteInDrill, grayInDrill };
                    }
                }

                if (!bestDrill) break; // No more drills

                // Apply drill: +1 for whites, +0.5 for grays (rounded up when applied)
                for (const attr of bestDrill.attrs) {
                    if (attr in simulatedStats) {
                        if (whiteAttrs.has(attr)) {
                            simulatedStats[attr] += 1; // White attributes increase by 1
                        } else {
                            // Gray attributes increase by 0.5, tracked with fractional part
                            grayFractional[attr] = (grayFractional[attr] || 0) + 0.5;
                            // Round up and apply
                            simulatedStats[attr] = Math.floor(playerStats[attr]) + Math.ceil(grayFractional[attr]);
                        }
                    }
                }

                steps.push({ drill: bestDrill, stats: { ...simulatedStats } });
                currentOverall = calculateOverallRatingWithStats(whiteAttrs, tierBonus, simulatedStats, attributes).base;
            }

            // Display summary
            const finalRatingObj = calculateOverallRatingWithStats(whiteAttrs, tierBonus, simulatedStats, attributes);
            const finalRating = finalRatingObj.base;
            const finalRatingWithBonus = finalRatingObj.withBonus;
            const initialRatingObj = calculateOverallRating(whiteAttrs, tierBonus);
            const initialRating = initialRatingObj.base;
            const initialRatingWithBonus = initialRatingObj.withBonus;

            const summaryBox = document.getElementById('planSummary');
            summaryBox.innerHTML = `
                <h3>ğŸ“Š ${t('planSummary')}</h3>
                <div style="font-size: 14px; line-height: 1.8;">
                    <div style="margin-bottom: 10px; padding: 10px; background: #e7f3ff; border-radius: 6px; border: 2px solid #2196F3;">
                        <strong style="color: #0d47a1;">${t('currentRating')}</strong><br>
                        <span style="font-size: 13px;">
                            ${t('overallBase')} <strong>${initialRating.toFixed(2)}</strong><br>
                            ${t('overallWithBonus')} <strong style="color: #667eea;">${initialRatingWithBonus.toFixed(2)}</strong>
                        </span>
                    </div>
                    <div><strong>${t('targetRating')}</strong> ${TARGET_RATING}</div>
                    <div style="margin-top: 10px; padding: 10px; background: #e7f3ff; border-radius: 6px; border: 2px solid #2196F3;">
                        <strong style="color: #0d47a1;">${t('newRating')}</strong><br>
                        <span style="font-size: 13px;">
                            ${t('overallBase')} <strong style="color: ${finalRating >= 180 ? '#28a745' : '#667eea'};">${finalRating.toFixed(2)}</strong><br>
                            ${t('overallWithBonus')} <strong style="color: ${finalRatingWithBonus >= 180 ? '#28a745' : '#667eea'};">${finalRatingWithBonus.toFixed(2)}</strong>
                        </span>
                    </div>
                </div>
            `;

            // Display final attributes
            const stepsContainer = document.getElementById('planSteps');
            stepsContainer.innerHTML = '';

            const finalAttrsBox = document.createElement('div');
            finalAttrsBox.className = 'summary-box';
            finalAttrsBox.style.marginBottom = '20px';

            let attrsHtml = `<h3>ğŸ“ˆ ${t('finalAttributes')}</h3>`;

            // Split attributes into 3 columns (5 each)
            const attrsList = attributes.filter(a => a in playerStats);
            attrsHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; direction: ltr;">';

            for (let col = 0; col < 3; col++) {
                attrsHtml += '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
                attrsHtml += '<tr style="background: #667eea; color: white;"><th style="padding: 8px;">Attribute</th><th style="padding: 8px; text-align: center;">Current</th><th style="padding: 8px; text-align: center;">Final</th><th style="padding: 8px; text-align: center;">+</th></tr>';

                // Each column shows 5 attributes
                const startIdx = col * 5;
                const endIdx = startIdx + 5;

                for (let i = startIdx; i < endIdx && i < attrsList.length; i++) {
                    const attr = attrsList[i];
                    const current = playerStats[attr];
                    const final = simulatedStats[attr];
                    const diff = final - current;
                    const isWhite = whiteAttrs.has(attr);
                    const bgColor = isWhite ? '#f1f9f3' : '#f8f9fa';

                    attrsHtml += `<tr style="background: ${bgColor};"><td style="padding: 8px; font-weight: ${isWhite ? '600' : '400'};">${t('attrs.' + attr)} ${isWhite ? 'â­' : ''}</td><td style="padding: 8px; text-align: center;">${current}</td><td style="padding: 8px; text-align: center; font-weight: 600; color: ${diff > 0 ? '#667eea' : '#666'};">${final}</td><td style="padding: 8px; text-align: center; color: ${diff > 0 ? '#28a745' : '#999'}; font-weight: ${diff > 0 ? '600' : '400'};">${diff > 0 ? '+' + diff : '0'}</td></tr>`;
                }

                attrsHtml += '</table>';
            }

            attrsHtml += '</div>';
            finalAttrsBox.innerHTML = attrsHtml;
            stepsContainer.appendChild(finalAttrsBox);

            // Group ALL instances of same drill (not just consecutive)
            const drillGroups = new Map();
            const drillOrder = []; // Track order of first appearance

            steps.forEach(step => {
                if (!drillGroups.has(step.drill.name)) {
                    drillGroups.set(step.drill.name, {
                        name: step.drill.name,
                        drill: step.drill,
                        count: 0
                    });
                    drillOrder.push(step.drill.name);
                }
                drillGroups.get(step.drill.name).count++;
            });

            // Calculate final stats after each unique drill
            const drillsToDisplay = drillOrder.map(name => drillGroups.get(name));

            // Sort drills: 0 grays (whites only), then 1 gray, then 2 grays, etc. - each sorted by difficulty
            const difficultyOrder = { 'VERY EASY': 1, 'EASY': 2, 'MEDIUM': 3, 'HARD': 4, 'VERY HARD': 5 };
            drillsToDisplay.sort((a, b) => {
                const aGrayCount = a.drill.grayInDrill.length;
                const bGrayCount = b.drill.grayInDrill.length;

                // First sort by number of grays (0, then 1, then 2, etc.)
                if (aGrayCount !== bGrayCount) {
                    return aGrayCount - bGrayCount;
                }

                // Within same gray count, sort by difficulty
                return difficultyOrder[a.drill.difficulty] - difficultyOrder[b.drill.difficulty];
            });

            // Display grouped drills
            let cumulativeStats = { ...playerStats };
            // Track fractional parts for gray attributes in display
            let displayGrayFractional = {};
            attributes.forEach(attr => {
                if (!whiteAttrs.has(attr) && attr in cumulativeStats) {
                    displayGrayFractional[attr] = 0;
                }
            });

            drillsToDisplay.forEach((item, index) => {
                // Apply this drill's effect to cumulative stats (+1 for whites, +0.5 for grays rounded up)
                item.drill.attrs.forEach(attr => {
                    if (attr in cumulativeStats) {
                        if (whiteAttrs.has(attr)) {
                            cumulativeStats[attr] += item.count * 1; // Whites increase by 1 per drill
                        } else {
                            // Grays increase by 0.5 per drill, tracked with fractional part
                            displayGrayFractional[attr] = (displayGrayFractional[attr] || 0) + (item.count * 0.5);
                            // Round up and apply
                            cumulativeStats[attr] = Math.floor(playerStats[attr]) + Math.ceil(displayGrayFractional[attr]);
                        }
                    }
                });

                // Calculate overall rating after this drill (both base and with bonus)
                const ratingAfterObj = calculateOverallRatingWithStats(whiteAttrs, tierBonus, cumulativeStats, attributes);
                const ratingAfter = ratingAfterObj.base;
                const ratingAfterWithBonus = ratingAfterObj.withBonus;

                const card = document.createElement('div');
                card.className = `drill-card category-${item.drill.category}`;
                card.style.background = item.drill.grayInDrill.length === 0 ? '#f1f9f3' : '#fffbf0';
                card.style.borderLeft = `5px solid ${item.drill.grayInDrill.length === 0 ? '#28a745' : '#ffc107'}`;

                if (currentLang === 'he') {
                    card.style.borderLeft = 'none';
                    card.style.borderRight = `5px solid ${item.drill.grayInDrill.length === 0 ? '#28a745' : '#ffc107'}`;
                }

                const whiteTrains = item.drill.whiteInDrill.map(a => `<span style="color: #28a745; font-weight: 600;">${t('attrs.' + a)}</span>`).join(', ');
                const grayTrains = item.drill.grayInDrill.map(a => `<span style="color: #6c757d;">${t('attrs.' + a)}</span>`).join(', ');

                // Calculate what the increases will be for this drill's attributes
                let attrsHtml = '<div style="margin-top: 12px; padding: 10px; background: rgba(102, 126, 234, 0.05); border-radius: 6px;">';
                attrsHtml += '<div style="font-size: 11px; font-weight: 600; color: #667eea; margin-bottom: 8px;">' + (currentLang === 'he' ? '×›×œ ×”×××¤×™×™× ×™× ××—×¨×™ ×ª×¨×’×™×œ ×–×”:' : 'All Attributes After This Drill:') + '</div>';
                attrsHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; font-size: 11px; direction: ltr;">';

                // Create 3 columns with 5 attributes each
                for (let col = 0; col < 3; col++) {
                    attrsHtml += '<div style="display: flex; flex-direction: column; gap: 6px;">';

                    const startIdx = col * 5;
                    const endIdx = startIdx + 5;

                    for (let i = startIdx; i < endIdx && i < attributes.length; i++) {
                        const attr = attributes[i];
                        if (attr in cumulativeStats) {
                            const value = cumulativeStats[attr];
                            const isBeingTrained = item.drill.attrs.includes(attr);
                            const isWhite = whiteAttrs.has(attr);
                            // Calculate increase: +1 for whites, +0.5 (rounded up) for grays
                            const increase = isBeingTrained ? (isWhite ? item.count * 1 : Math.ceil(item.count * 0.5)) : 0;

                            attrsHtml += `
                                <div style="padding: 4px 6px; background: ${isWhite ? '#f1f9f3' : '#f8f9fa'}; border-radius: 4px; ${isBeingTrained ? 'border: 2px solid #667eea;' : ''}">
                                    <div style="font-weight: ${isWhite ? '600' : '400'}; color: ${isBeingTrained ? '#667eea' : '#333'}; font-size: 10px;">
                                        ${t('attrs.' + attr)}${isWhite ? ' â­' : ''}
                                    </div>
                                    <div style="font-weight: 600; color: ${increase > 0 ? '#667eea' : '#666'}; font-size: 13px;">
                                        ${Math.round(value)}${increase > 0 ? ` <span style="color: #28a745; font-size: 10px;">+${increase}</span>` : ''}
                                    </div>
                                </div>
                            `;
                        }
                    }

                    attrsHtml += '</div>';
                }

                attrsHtml += '</div></div>';

                card.innerHTML = `
                    <h3 style="color: #667eea;">
                        ${t('drills.' + item.drill.name)}
                        <span class="badge badge-category badge-${item.drill.category}">${t(item.drill.category)}</span>
                        <span class="badge badge-difficulty">${t('difficulties.' + item.drill.difficulty)}</span>
                    </h3>
                    <div style="font-size: 13px; margin-top: 8px; margin-bottom: 8px;">
                        <strong>${t('trains')}</strong> ${whiteTrains}${grayTrains ? ', ' + grayTrains : ''}
                    </div>
                    <div style="font-size: 13px; padding: 8px; background: #e7f3ff; border-radius: 6px; border: 2px solid #2196F3; margin-bottom: 8px;">
                        <strong style="color: #0d47a1;">${currentLang === 'he' ? '×“×™×¨×•×’ ××—×¨×™:' : 'Overall After:'}</strong><br>
                        <span style="font-size: 12px;">
                            ${t('overallBase')} <strong style="color: ${ratingAfter >= 180 ? '#28a745' : '#667eea'};">${ratingAfter.toFixed(2)}</strong><br>
                            ${t('overallWithBonus')} <strong style="color: ${ratingAfterWithBonus >= 180 ? '#28a745' : '#667eea'};">${ratingAfterWithBonus.toFixed(2)}</strong>
                        </span>
                    </div>
                    ${attrsHtml}
                `;

                stepsContainer.appendChild(card);
            });
        }

        function calculateOverallRatingWithStats(whiteAttrs, tierBonus, stats, attributes) {
            let totalBase = 0;
            let totalWithBonus = 0;
            let count = 0;

            attributes.forEach(attr => {
                if (attr in stats) {
                    totalWithBonus += stats[attr];
                    totalBase += whiteAttrs.has(attr) ? stats[attr] - tierBonus : stats[attr];
                    count++;
                }
            });

            return {
                base: count > 0 ? totalBase / count : 0,
                withBonus: count > 0 ? totalWithBonus / count : 0
            };
        }

        function buildFilterCheckboxes() {
            const whiteAttrs = new Set(ROLE_WHITES[selectedRole]);
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            const grid = document.getElementById('filterAttrGrid');
            grid.innerHTML = '';

            attributes.forEach(attr => {
                const isWhite = whiteAttrs.has(attr);
                const label = document.createElement('label');
                label.className = 'filter-attr-item' + (isWhite ? ' is-white' : '');
                label.innerHTML = `
                    <input type="checkbox" id="fattr_${attr}" onchange="onAttrFilterChange()">
                    ${t('attrs.' + attr)}${isWhite ? ' â­' : ''}
                `;
                grid.appendChild(label);
            });
        }

        function onAttrFilterChange() {
            renderDrillList();
        }

        function getCheckedAttrs() {
            const attributes = selectedRole === 'GK' ? GK_ATTRIBUTES : REGULAR_ATTRIBUTES;
            return new Set(attributes.filter(attr => {
                const cb = document.getElementById('fattr_' + attr);
                return cb && cb.checked;
            }));
        }

        function drillMatchesFilter(drill, checkedAttrs) {
            // No attributes checked = show all
            if (checkedAttrs.size === 0) return true;
            // AND logic: drill must train every checked attribute
            const allDrillAttrs = new Set([...(drill.whiteAttrs || []), ...(drill.grayAttrs || [])]);
            return [...checkedAttrs].every(a => allDrillAttrs.has(a));
        }

        function renderDrillList() {
            const checkedAttrs = getCheckedAttrs();

            const filtered = (drills) => drills.filter(d => drillMatchesFilter(d, checkedAttrs));

            const whiteDrills = filtered(cachedWhiteDrills);
            const mixedDrills = filtered(cachedMixedDrills);
            const grayDrills = filtered(cachedGrayDrills);

            const list = document.getElementById('recommendationsList');
            list.innerHTML = '';

            if (whiteDrills.length > 0) {
                list.innerHTML += `<div class="priority-header white">${t('priority1')}</div>`;
                whiteDrills.forEach(drill => list.appendChild(createDrillCard(drill, 'white')));
            }

            if (mixedDrills.length > 0) {
                list.innerHTML += `<div class="priority-header mixed">${t('priority2')}</div>`;
                mixedDrills.forEach(drill => list.appendChild(createDrillCard(drill, 'mixed')));
            }

            if (grayDrills.length > 0) {
                list.innerHTML += `<div class="priority-header gray">${t('priority3')}</div>`;
                grayDrills.forEach(drill => list.appendChild(createDrillCard(drill, 'gray')));
            }

            if (whiteDrills.length === 0 && mixedDrills.length === 0 && grayDrills.length === 0) {
                list.innerHTML = `<div class="no-drills">${t('noDrills')}</div>`;
            }
        }

        function backToRecommendations() {
            showSection('recommendationsSection');
        }

        function backToRoles() {
            showSection('roleSection');
            selectedRole = null;
            playerStats = {};
            playerTier = "None";
            document.querySelectorAll('.role-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('selectedRoleBox').classList.remove('show');
        }

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
            window.scrollTo({top: 0, behavior: 'smooth'});
        }

        initRoleGrid();
    </script>
</body>
</html>


